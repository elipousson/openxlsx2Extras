% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/read_xlsx_ext.R
\name{read_xlsx_ext}
\alias{read_xlsx_ext}
\title{Create a data frame from a Workbook (with extra features)}
\usage{
read_xlsx_ext(
  file,
  sheet = 1,
  ...,
  names_from = "basename",
  names_to = rlang::zap(),
  combine = TRUE,
  repair = "unique_quiet"
)
}
\arguments{
\item{file}{An xlsx file, \link[openxlsx2]{wbWorkbook} object or URL to xlsx file.}

\item{sheet}{Defaults to 1.}

\item{...}{
  Arguments passed on to \code{\link[openxlsx2:wb_to_df]{openxlsx2::read_xlsx}}
  \describe{
    \item{\code{start_row}}{first row to begin looking for data.}
    \item{\code{start_col}}{first column to begin looking for data.}
    \item{\code{row_names}}{If \code{TRUE}, the first col of data will be used as row names.}
    \item{\code{col_names}}{If \code{TRUE}, the first row of data will be used as column names.}
    \item{\code{skip_empty_rows}}{If \code{TRUE}, empty rows are skipped.}
    \item{\code{skip_empty_cols}}{If \code{TRUE}, empty columns are skipped.}
    \item{\code{rows}}{A numeric vector specifying which rows in the xlsx file to read.
If \code{NULL}, all rows are read.}
    \item{\code{cols}}{A numeric vector specifying which columns in the xlsx file to read.
If \code{NULL}, all columns are read.}
    \item{\code{detect_dates}}{If \code{TRUE}, attempt to recognize dates and perform conversion.}
    \item{\code{na.strings}}{A character vector of strings which are to be interpreted as \code{NA}.
Blank cells will be returned as \code{NA}.}
    \item{\code{na.numbers}}{A numeric vector of digits which are to be interpreted as \code{NA}.
Blank cells will be returned as \code{NA}.}
    \item{\code{fill_merged_cells}}{If \code{TRUE}, the value in a merged cell is given to all cells within the merge.}
    \item{\code{named_region}}{Character string with a \code{named_region} (defined name or table).
If no sheet is selected, the first appearance will be selected. See \code{\link[openxlsx2:wb_get_named_regions]{wb_get_named_regions()}}}
    \item{\code{check_names}}{If \code{TRUE} then the names of the variables in the data frame are checked to ensure that they are syntactically valid variable names.}
    \item{\code{show_hyperlinks}}{If \code{TRUE} instead of the displayed text, hyperlink targets are shown.}
  }}

\item{names_to}{By default, \code{names(x)} are lost. To keep them, supply a
string to \code{names_to} and the names will be saved into a column with that
name. If \code{names_to} is supplied and \code{x} is not named, the position of
the elements will be used instead of the names.}

\item{combine}{If \code{TRUE}, always return a data frames. If \code{FALSE}, return a
list of data frames.}

\item{repair}{Either a string or a function. If a string, it must be one of
\code{"check_unique"}, \code{"minimal"}, \code{"unique"}, \code{"universal"}, \code{"unique_quiet"},
or \code{"universal_quiet"}. If a function, it is invoked with a vector of
minimal names and must return minimal names, otherwise an error is thrown.
\itemize{
\item Minimal names are never \code{NULL} or \code{NA}. When an element doesn't
have a name, its minimal name is an empty string.
\item Unique names are unique. A suffix is appended to duplicate
names to make them unique.
\item Universal names are unique and syntactic, meaning that you can
safely use the names as variables without causing a syntax
error.
}

The \code{"check_unique"} option doesn't perform any name repair.
Instead, an error is raised if the names don't suit the
\code{"unique"} criteria.

The options \code{"unique_quiet"} and \code{"universal_quiet"} are here to help the
user who calls this function indirectly, via another function which exposes
\code{repair} but not \code{quiet}. Specifying \code{repair = "unique_quiet"} is like
specifying \verb{repair = "unique", quiet = TRUE}. When the \code{"*_quiet"} options
are used, any setting of \code{quiet} is silently overridden.}
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

\code{\link[=read_xlsx_ext]{read_xlsx_ext()}} uses \code{\link[openxlsx2:wb_to_df]{openxlsx2::read_xlsx()}} with a few added features:
\itemize{
\item allows use of a name repair argument (\code{"unique_quite"} by default) to avoid
blank \code{""} or \code{NA} values for column names.
\item allows vector inputs for the file or sheet argument. These parameters are
recycled to a common length and result in the return of a data frame list
unless the \code{combine = TRUE} is set. If \code{combine = TRUE}, set \code{names_to}
(passed to \code{purrr::list_rbind}) to combined the file basename values
(default) or full path values as a column (depending on the \code{names_from}
argument). \code{names_from} can also be a length > 1 character vector that can be
recycled to match the length of file.
}
}
